<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>净无涯的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="净无涯的博客">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="净无涯的博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="净无涯的博客">
  
    <link rel="alternate" href="/atom.xml" title="净无涯的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">净无涯的博客</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JSON" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/08/JSON/" class="article-date">
  <time datetime="2017-10-08T07:46:54.000Z" itemprop="datePublished">2017-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/08/JSON/">JavaScript 和 JSON</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>数据格式：XML，JSON，YAML…，用过后面两个，当然从我开始接触互联网，使用的最多的也还是JSON，从PHP传输JSON到现在JavaScript传输JSON，这篇文章主要写的是JavaScript 的JSON。</p>
<h2 id="1-JSON-语法和JavaScript-的数据类型"><a href="#1-JSON-语法和JavaScript-的数据类型" class="headerlink" title="1. JSON 语法和JavaScript 的数据类型"></a>1. JSON 语法和JavaScript 的数据类型</h2><h3 id="1-1-JSON-表示简单值"><a href="#1-1-JSON-表示简单值" class="headerlink" title="1.1 JSON 表示简单值"></a>1.1 JSON 表示简单值</h3><p>JSON表示简单值和JavaScript 的语法相同，JSON可以表示字符串、数值、布尔值、null，但是 <strong>JSON不支持JavaScript 的特殊值undefined</strong> ，记住这一点就可以了。另一点就是JavaScript 字符串既可以使用单引号也可以使用双引号，但是 <strong>JSON字符串必须是双引号</strong> 。</p>
<h3 id="1-2-JSON-表示对象"><a href="#1-2-JSON-表示对象" class="headerlink" title="1.2 JSON 表示对象"></a>1.2 JSON 表示对象</h3><p><strong>重要：JSON中的对象的属性必须要加双引号</strong> ，其他就没有什么区别了。JavaScript 的对象字面量：</p>
<pre><code>var person = {
    name: &apos;Tom&apos;,
    age: 29
};
</code></pre><p>JSON中的对象表示为：</p>
<pre><code>{
    &quot;name&quot;: &quot;Tom&quot;,
    &quot;age&quot;: 29
}
</code></pre><h3 id="1-3-JSON-表示数组"><a href="#1-3-JSON-表示数组" class="headerlink" title="1.3 JSON 表示数组"></a>1.3 JSON 表示数组</h3><p>JSON数组就是JavaScript 的数组字面量形式，比较简单。</p>
<blockquote>
<p>总结：JSON 来表示JavaScript 的数据，1. undefined不能表示， 2. 字符串必须是双引号， 3. 对象的属性名必须加上双引号。</p>
</blockquote>
<h2 id="2-JSON-解析和序列化"><a href="#2-JSON-解析和序列化" class="headerlink" title="2. JSON 解析和序列化"></a>2. JSON 解析和序列化</h2><p>这里才是重点，为什么要做解析和序列化？AJAX发送数据到服务器，其中一步就是要把JavaScript 的数据对象转化为JSON数据，服务器接受后再使用别的语言（PHP，Python）把JSON数据转化为相应的数据对象（比如Python字典），在网络传输的数据大部分都是JSON数据。</p>
<h3 id="2-1-序列化-stringify"><a href="#2-1-序列化-stringify" class="headerlink" title="2.1 序列化 stringify()"></a>2.1 序列化 stringify()</h3><p>早期的JSON解释器是使用JavaScript 的 <strong>eval()</strong> 函数，它可以解析，解释并返回JavaScript 对象和数组。但是很明显 <strong>eval()</strong> 函数本身有风险，因此现在都不会再使用这种方法。</p>
<p>现在的JavaScript （ES5）定义了全局对象 <strong>JSON对象</strong> ， 有两个方法： <strong>stringify()</strong> 负责把JavaScript 对象序列化为JSON字符串， <strong>parse()</strong> 负责把JSON字符串解析为JavaScript 值。</p>
<p>JSON.stringify()方法接受三个参数，第一个是要序列化的JavaScript 对象，第二个是过滤器（可以使数组或者是替换函数），第三个是控制缩进和空白符。过滤器是数组，那么结果中将只包含数组列出的属性，看下面的例子：</p>
<pre><code>var book = {
    title: &apos;Book&apos;,
    anthors: [&apos;Tom&apos;, &apos;Jerry&apos;],
    edition: 3,
    releaseDate: new Date(2011, 11, 1)
};
var jsonText = JSON.stringify(book, [&apos;title&apos;, &apos;edition&apos;]);
console.log(jsonText);
// {&quot;title&quot;:&quot;Book&quot;,&quot;edition&quot;:3}
</code></pre><p>上述代码，通过 <strong>JSON.stringify()</strong> 序列化JavaScript 对象得到的JSON字符串只包含了过滤器数组中包含的属性 <strong>title，edition</strong> 。如果过滤器是一个函数，叫做 <strong>替换函数</strong> ，函数返回的值就是相应键的值，如果返回的是undefined，相应的属性就会被忽略，看下面的例子：</p>
<pre><code>var book = {
    title: &apos;Book&apos;,
    anthors: [&apos;Tom&apos;, &apos;Jerry&apos;],
    edition: 3,
    releaseDate: new Date(2011, 11, 1)
};
var jsonText = JSON.stringify(book, function(key, value) {
    switch(key) {
        case &apos;anthors&apos;:
            return value.join(&apos;,&apos;);
        case &apos;releaseDate&apos;:
            return undefined;
        default:
            return value;
    }
});
console.log(jsonText);
// {&quot;title&quot;:&quot;Book&quot;,&quot;anthors&quot;:&quot;Tom,Jerry&quot;,&quot;edition&quot;:3}
</code></pre><p>上述代码使用了替换函数，对于属性 <strong>authors</strong> ，返回了数组连接的字符串，并且通过返回undefined忽略了属性 <strong>releaseDate</strong> ，其他属性直接返回。</p>
<p>第三个参数用于控制结果中的缩进和空白符，如果是数值表示每个级别缩进的空格数（不超过10），如果是字符串，则被用来当做缩进字符（字符串长度不超过10），下面的例子：</p>
<pre><code>console.log(JSON.stringify(book, null, 4));
// {
//     &quot;title&quot;: &quot;Book&quot;,
//     &quot;anthors&quot;: [
//         &quot;Tom&quot;,
//         &quot;Jerry&quot;
//     ],
//     &quot;edition&quot;: 3,
//     &quot;releaseDate&quot;: &quot;2011-11-30T16:00:00.000Z&quot;
// }
console.log(JSON.stringify(book, null, &apos;- - &apos;));
// {
// - - &quot;title&quot;: &quot;Book&quot;,
// - - &quot;anthors&quot;: [
// - - - - &quot;Tom&quot;,
// - - - - &quot;Jerry&quot;
// - - ],
// - - &quot;edition&quot;: 3,
// - - &quot;releaseDate&quot;: &quot;2011-11-30T16:00:00.000Z&quot;
// }
</code></pre><h3 id="2-2-解析-parse"><a href="#2-2-解析-parse" class="headerlink" title="2.2 解析 parse()"></a>2.2 解析 parse()</h3><p>JSON.parse()方法接受两个参数，第一个是解析的JSON字符串，第二个是 <strong>还原函数</strong> 。还原函数返回 <strong>undefined</strong> ，表示要从结果中删除相应的键，如果返回其他值，就将该值插入到结果中。特别是日期字符串转换为Data对象时需要用到还原函数，见下面的例子：</p>
<pre><code>var book = {
    title: &apos;Book&apos;,
    anthors: [&apos;Tom&apos;, &apos;Jerry&apos;],
    edition: 3,
    releaseDate: new Date(2011, 11, 1),
    option: null
};
var jsonText = JSON.stringify(book);
console.log(jsonText);
// {&quot;title&quot;:&quot;Book&quot;,&quot;anthors&quot;:[&quot;Tom&quot;,&quot;Jerry&quot;],&quot;edition&quot;:3,
// &quot;releaseDate&quot;:&quot;2011-11-30T16:00:00.000Z&quot;,&quot;option&quot;:null}
var bookCopy = JSON.parse(jsonText, function(key, value) {
    if(key === &apos;releaseDate&apos;) {
        return new Date(value);
    } else if(key === &apos;option&apos;) {
        return undefined;
    } else {
        return value;
    }
});
console.log(bookCopy);
</code></pre><p>上述代码首先定义了一个JavaScript 对象，一共有5个属性，其中 <strong>releaseDate</strong> 属性是一个Date对象。然后使用 <strong>JSON.stringify()</strong> 方法进行序列化得到JSON字符串，可以看到JSON字符串里对象的属性名加上了双引号，字符串也是双引号。最后使用 <strong>JSON.parse()</strong> 方法进行解析还原JavaScript 对象，其中使用了 <strong>还原函数</strong> ，对于属性 <strong>option</strong> ，通过返回undefined 删除该属性，对于属性 <strong>releaseDate</strong> ，返回new Date(value)得到一个Date对象，其他属性直接返回，最终结果如下所示：</p>
<p><img src="/img/json1.png" alt="Alt text"></p>
<p>第一稿于2017.10.8</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/08/JSON/" data-id="cj8imchlj0005e6jxn3d0p022" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-js-setTimeout" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/08/js-setTimeout/" class="article-date">
  <time datetime="2017-10-08T06:33:03.000Z" itemprop="datePublished">2017-10-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/08/js-setTimeout/">JavaScript 超时和间歇调用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript 虽然是 <strong>单线程</strong> 语言，不过仍然提供了两种方法来调度代码在特定的时间执行。</p>
<h2 id="1-超时调用-setTimeout"><a href="#1-超时调用-setTimeout" class="headerlink" title="1. 超时调用 setTimeout()"></a>1. 超时调用 setTimeout()</h2><p>这应该会是平时经常用到的，让代码经过一段事件再执行，比如倒计时就会用到，另外JavaScript 的动画实现也需要用到它。</p>
<ol>
<li>它是 <strong>window对象</strong> 的方法，因此超时调用的代码都是在 <strong>全局作用域</strong> 中执行的（全局作用域中，非严格模式this指向window对象，严格模式this是undefined）。</li>
<li>两个参数，第一个是函数，第二个是表示等待多长时间的毫秒数。 重点来了：经过该时间后指定的代码不一定会执行。 <strong>之前说了，JavaScript 是一个单线程的解释器，意味着同一时间只能执行一段代码，所有代码都要放到JavaScript 的任务队列中去，这些任务按照添加的顺序来执行。</strong> 这里提到了任务队列，这就是JavaScript 的执行流。 因此第二个参数的时间只是表示还有多少时间把指定的任务放到任务队列，至于什么时候执行要看任务队列的情况。如果队列空的，那当然就会立即执行，如果不是空的，那就慢慢等吧，所以第二个参数的时间，不是确定的代码执行的时间。</li>
<li><p>调用setTimeout()会返回一个 <strong>数值ID</strong> ， 表示计划执行代码的唯一标识符，用来取消计划的。使用 <strong>clearTimeout()</strong> 并传入这个数值ID就可以取消超时调用。</p>
<pre><code>setTimeout(function () {
    console.log(&apos;setTimeout.&apos;)
}, 3000);
</code></pre></li>
</ol>
<p>执行上述代码，3秒后（之前解释不一定是3秒）会控制台会打印“setTimeout.”，再看如何取消这个超时调用：</p>
<pre><code>var timeoutID = setTimeout(function () {
    console.log(&apos;setTimeout.&apos;)
}, 3000);
console.log(timeoutID);  // 1
clearTimeout(timeoutID);
</code></pre><p>执行上述代码，什么都不会发生，3秒之后也不会打印，因为在3秒到达之前已经通过 <strong>clearTimeout()</strong> 把这个超时调用取消了。</p>
<h2 id="2-间歇调用-setInterval"><a href="#2-间歇调用-setInterval" class="headerlink" title="2. 间歇调用 setInterval()"></a>2. 间歇调用 setInterval()</h2><p>和setTimeout()类似，不过它会按照指定的时间间隔重复执行代码。但最好不要使用间歇调用，原因后面会仔细解释。</p>
<ol>
<li>它也是 <strong>window对象</strong> 的方法，指定的代码需要在 <strong>全局作用域</strong> 中执行。</li>
<li>两个参数，和 <strong>setTimeout</strong> 一样。</li>
<li>同样也会有一个 <strong>数值ID</strong> ，用来取消间歇调用。不过取消间歇调用非常重要，因为 <strong>间歇调用会一直执行到页面卸载</strong> 。</li>
</ol>
<p>下面的例子使用间歇调用来模拟倒计时（10-0）：</p>
<pre><code>var num = 11;
var min = 0;
function decrementNumber() {
    num--;
    console.log(num);
    if(num === min) {
        clearInterval(intervalID);
    }
}
var intervalID = setInterval(decrementNumber, 1000);
</code></pre><p>执行上述代码，控制台每隔1秒会依次打印10-0 ，完成倒计时。</p>
<p>在介绍间歇调用 <strong>setInterval</strong> 的时候，说过最好不要使用，上面的例子看似很好，其实暗藏了很大的隐患。如果想到了在介绍超时调用 <strong>setTimeout</strong> 时提到过JavaScript 的任务队列，参数里的时间只是表示经过多少时间把代码放到任务队列，不一定会立即执行。因此在间歇调用的时候每隔固定时间都会把代码放进任务队列，当任务队列比较多的时候，可能出现 <strong>后一个间歇调用在前一个间歇调用结束之前启动</strong> 。为了避免这种现象，实际开发中都是使用超时调用来模拟间歇调用，在确认上一次超时调用结束后再启动下一次超时调用。上面倒计时的例子用超时调用来改写：</p>
<pre><code>var num = 11;
var min = 0;
function decrementNumber() {
    num--;
    console.log(num);
    if(num !== min) {
        setTimeout(decrementNumber, 1000);
    }
}
setTimeout(decrementNumber, 1000);
</code></pre><p>使用超时调用 <strong>setTimeout()</strong> 来模拟间歇调用 <strong>setInterval()</strong> 是一种最佳实践，其实这两种办法都没有做到精确的任务调用，尤其是任务比较多的时候，指定的时间可能会有较大的延迟，这取决于JavaScript 是单线程解释。</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><blockquote>
<p>详细介绍了JavaScript 中超时调用setTimeout和间歇调用setInterval，由于JavaScript 是单线程解释器，所以导致这两种方法都不能做到精确的任务调度。另外尽量使用超时调用setTimeout来模拟间歇调用setInterval，避免出现调度错乱的情况。</p>
</blockquote>
<p>第一稿于2017.10.8</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/08/js-setTimeout/" data-id="cj8imchls000be6jxhkuwpdmo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-http" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/http/" class="article-date">
  <time datetime="2017-10-07T07:47:56.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/http/">HTTP 概述</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>作为前端工程师，HTTP协议是必须了解的。这篇文章不讨论具体的细节，从宏观上来总结HTTP协议。</p>
<h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><blockquote>
<p>HTTP（超文本传输协议）是服务器和客户端之间通过请求/响应模式传输超文本（HTML文件，CSS文档、JavaScript脚本，图片等）内容的协议。</p>
</blockquote>
<h2 id="HTTP报文"><a href="#HTTP报文" class="headerlink" title="HTTP报文"></a>HTTP报文</h2><p>HTTP报文有 <strong>头部、空行、正文</strong> 组成。</p>
<p>请求报文格式：</p>
<p><img src="/img/http1.jpg" alt="Alt text"></p>
<p>响应报文格式：</p>
<p><img src="/img/http2.png" alt="Alt text"></p>
<h2 id="HTTP-1-1-使用最广泛的HTTP版本"><a href="#HTTP-1-1-使用最广泛的HTTP版本" class="headerlink" title="HTTP 1.1 使用最广泛的HTTP版本"></a>HTTP 1.1 使用最广泛的HTTP版本</h2><h3 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h3><p>HTTP1.1 的长连接依赖HTTP请求头部的 <strong>keep-alive</strong> ，</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/http/" data-id="cj8imchlr000ae6jxyvivcthv" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-prototype" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/07/prototype/" class="article-date">
  <time datetime="2017-10-07T06:44:44.000Z" itemprop="datePublished">2017-10-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/07/prototype/">继承，从原型链说起</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>JavaScript 的面向对象，虽然比不上C++那么复杂，但是它也很灵活，尤其是ES6新特性，在面向对象这里提出了很多新的方法，使得JavaScript 的面向对象也越来越有范。面向对象里最重要的应该就是继承了，实现了代码的重用，所以我会同时写两篇文章《继承，从原型链说起》和《ES6带来了类》，分别从传统JavaScript 和ES6 来探讨继承古老而又创新的话题。这篇文章主要写的都是基础，当然也会穿插一些新的内容。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/07/prototype/" data-id="cj8imchlu000ce6jxs16u2uqf" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-closure" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/05/closure/" class="article-date">
  <time datetime="2017-10-05T08:17:54.000Z" itemprop="datePublished">2017-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/05/closure/">闭包，从作用域链说起</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>曾经在CSDN上写过一篇文章《闭包，应该从作用域链说起》。那篇文章写得比较啰嗦，打算重新写一次，力求写得更明白更直接。</p>
<h2 id="闭包是什么"><a href="#闭包是什么" class="headerlink" title="闭包是什么"></a>闭包是什么</h2><p>校招参加面试，基本上都会问问你是怎么理解闭包的，我的回答是闭包应该从作用域链上的角度来说，因为如果没有作用域链，就根本不会出现闭包。闭包引用了包含函数的活动对象，因此它可以访问包含函数的变量。所以我打算从作用域开始写起。</p>
<h2 id="执行环境和变量对象"><a href="#执行环境和变量对象" class="headerlink" title="执行环境和变量对象"></a>执行环境和变量对象</h2><p>JavaScript 经常会提起<strong>执行环境</strong>（后面简称环境），毫不夸张这个概念应该是JavaScript 中最重要的了。</p>
<blockquote>
<p><strong>环境</strong>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个环境都有一个关联的<strong>变量对象</strong>，环境中定义的所有变量和函数都保存在这个对象中。</p>
</blockquote>
<p>我们现在开始从JavaScript 的底层来解析我们的代码是怎么执行的，所以一开始的时候会慢慢来解释所有概念。从上面的解释来看，环境是什么？应该是可以访问的变量，环境和变量对象是对应的，能访问的变量和函数都存在这个变量对象中。这样解释也很难理解，用一个简单的例子来说明：window对象都应该比较熟悉，所有的全局变量和函数都是作为window对象的属性和方法，看下面的例子:</p>
<pre><code>var tmp =&apos;hello&apos;;
function myFunc() {
  console.log(&apos;hello&apos;);
}
console.log(tmp === window.tmp);        // true
console.log(myFunc === window.myFunc);  // true
</code></pre><p>window对象就被认为是一个全局环境（最外围的一个环境），按照定义来说全局环境和window对象关联，<strong>在全局环境中定义的变量和函数都保存在window对象中</strong>。这一步应该可以理解，再重复一遍，全局环境的变量对象就是window对象，全局环境中的变量和函数都保存在window对象中，第一步就理解到这里。</p>
<p>第二步我们说说环境的特点：<strong>某个环境的代码执行完毕后，该环境就会被销毁，保存在其中的所有变量和函数定义都会随之销毁</strong>。比如我们已经知道了全局环境，它什么时候销毁呢？当应用程序退出的时候（关闭网页或浏览器），这个全局环境就会被销毁，该环境中的变量和函数都不存在了，因为保存它们的window对象被销毁了。那么除了全局环境，还有什么环境？那就是函数环境了，其实也只有两种环境（全局环境和函数环境）。下一步再详细说明的就是函数的环境。</p>
<blockquote>
<p>每一个函数都有自己的环境，当执行流进入一个函数时，<strong>函数环境</strong>会被推入一个函数栈中。而在函数执行完成之后，栈会将其环境弹出，把控制权返回给之前的执行环境。</p>
</blockquote>
<p>相比于全局环境，函数环境才是我们最关心的。上面一段话也解释了JavaScript 是如何执行我们的代码的，依靠环境栈来控制执行流，到目前为止我们总结一下：<strong>环境和变量对象（全局环境和window对象，函数环境和变量对象），环境的特点，环境栈（JavaScript 执行流）</strong>。</p>
<h2 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h2><p>在理解前面的环境和变量对象之后，就要面对这篇文章最核心的内容：作用域链。</p>
<blockquote>
<p>代码在环境中执行时，会为变量对象创建一个<strong>作用域链</strong>，它的作用是保证对环境有权访问的所有变量和函数的有序访问。作用域链的前端总是当前执行的代码所在环境的变量对象。</p>
<p>如果是函数环境，变量对象则为“<strong>活动对象</strong>”，在最开始的时候只包含一个变量（arguments对象）。作用域链的下一个变量对象来自包含（外部）环境，而再下一个变量对象来自下一个外部环境，全局环境的变量对象（window对象）始终是作用域链中的最后一个变量对象。</p>
</blockquote>
<p>上面两段话，用最简洁的语言表达了作用域链，当然也很难理解。有几个关键的地方使我们需要注意的：</p>
<ol>
<li>作用域链是一条环境的变量对象的链，每一个值都是一个环境的变量对象。</li>
<li>作用域链的作用是实现了有序访问，既然是链那就有方向，第一个是当前环境的变量对象，最后一个是全局环境的window对象。</li>
<li>函数环境的变量对象叫做活动对象。</li>
</ol>
<p>下面这个例子我会一行一行代码地来分析：</p>
<pre><code>function add(num1, num2) {
  var sum = num1 + num2;
  return sum;
}
var total = add(5, 10);
console.log(total);
</code></pre><p>这个例子很简单，首先定义了一个函数 <strong>add()</strong> ，然后定义了一个变量 <strong>total</strong> ，它的值是函数执行后的结果。根据之前的概念，在这里我们分步骤来详细解释JavaScript 到底是如何来执行代码的。</p>
<ol>
<li>创建函数add()时发生的事情：在创建add()函数时，会创建一个预先包含全局变量对象（window对象）的作用域链，这个作用域链被保存在函数内部 <strong>[[Scope]]</strong> 属性中，下面这张图片就解释了这个过程，注意在函数创建的时候就已经有作用域链了。</li>
</ol>
<p><img src="/img/scope.jpg" alt="Alt text"></p>
<p>再详细说明一遍，函数创建的时候，函数的属性 <strong>[[Scope]]</strong> 会指向一个原先创建的作用域链，该作用域链已经包含了全局变量对象（window对象）。</p>
<ol>
<li>函数add()执行发生的事情：当调用函数add()时，会为函数创建一个函数环境。首先复制函数的 <strong>[[Scope]]</strong> 属性中对象来构建环境的作用域链，然后活动对象（函数环境的变量对象）被创建并被推入到该环境的作用域链的前端，该过程依旧可以使用下面的图片详细解释：</li>
</ol>
<p><img src="/img/scope2.jpg" alt="Alt text"></p>
<p>看图说话，最左边是在调用函数add()时创建的函数环境，第一步先把函数的内部属性 <strong>[[Scope]]</strong> 复制过来构建该函数环境的作用域链，然后创建该函数环境的活动对象（函数环境的变量对象叫做活动对象），最后把该活动对象推入到作用域链的前端，所以可以看到函数环境的活动对象在作用域链的第一位，全局变量对象排在第二位。</p>
<p>到目前为止，我们比较清楚地了解作用域链是如何生成的。有两个阶段，创建函数的时候就预先创建了作用域链，调用函数的时候创建活动对象推入到作用域链的前端。回过头来，作用域链的作用是保证对环境有权访问的所有变量和函数的有序访问，这又是靠什么实现的？</p>
<blockquote>
<p><strong>标识符解析</strong> 是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（找不到就会报错）。</p>
</blockquote>
<p>我们辛辛苦苦去理解和创建作用域链的目的，就是提供一个有序的方法来搜索 <strong>标识符</strong> ，作用域链就保证了搜索的过程是有先后的，从作用域链的前面开始，一级一级地向后搜索，直至最外面的全局变量对象。这一下应该明白了 JavaScript 在函数里可以访问函数外的变量。</p>
<p>再举一个例子，不嫌麻烦地把之前的过程再来一遍，并且展示 <strong>标识符解析</strong> 的过程，例子还是很简单，但是能把背后的作用域链弄得很清楚还是不容易的：</p>
<pre><code>var color = &apos;blue&apos;;
function changeColor() {
  var anotherColor = &apos;red&apos;;
  function swapColors() {
    var tempColor = anotherColor;
    anotherColor = color;
    color = tempColor;
    // 这里可以color，anotherColor， tempColor
    console.log(color, anotherColor, tempColor);
  }
  swapColors();
  // 这里可以color，anotherColor，不能访问tempColor
  console.log(color, anotherColor);
}
changeColor();
// 这里可以color，不能访问tempColor，anotherColor
console.log(color);
</code></pre><p>这个例子上之前的例子稍微复杂一点，还是慢慢一步步来分析。</p>
<ol>
<li>定义一个变量 <strong>color</strong> ，该变量看做是全局变量对象（window对象）的一个属性；</li>
<li>创建了一个函数changeColor()，该函数看做是window对象的一个方法，并且创建函数的时候会创建一个预先包含全局变量对象的的作用域链，保存在该函数的内部属性 <strong>[[Scope]]</strong> 中，如下图所示：<img src="/img/scope3.jpg" alt="Alt text"></li>
<li>调用函数changeColor()，会创建函数环境并且会复制函数的内部属性来构建自己的作用域链，同时会创建该函数环境的活动对象并推入到作用域链的前端，不过在函数执行过程中又创建了另一个函数swapColors()，同样的道理该函数在创建的时候也会预先创建一个作用域链，<strong>不同的是这个预先创建的作用域链不仅包括全局变量对象还包括了包含函数（外部函数changeColor）的活动对象</strong> ，这一点非常重要。我先画调用changeColor函数的示意图，再画创建swapColor函数的示意图。 <img src="/img/scope4.jpg" alt="Alt text"> 再次不嫌啰嗦的详细解释一下，代码运行到 <strong>changeColor();</strong> ，调用函数changeColor首先会创建一个该函数的环境，图上最左边的框代表这个函数环境，接下来第一件事就是复制函数的内部属性 <strong>[[Scope]]</strong> 来创建该函数环境的作用域链，这里指的就是window对象。第二步就是创建函数环境本身的活动对象，环境里定义的变量 <strong>anotherColor</strong> 和函数 <strong>swapColors</strong> ，还包括 <strong>arguments对象</strong> 都保存在这个活动对象里，图中右上角的框表示的就是这个活动对象。最后一步就是把这个活动对象推入到作用域链的前端，因此我们看到在作用域链里，该函数环境的活动对象是排在第一位的，window对象是排在第二位的。并且按照 <strong>标识符解析</strong> 的规则，在这个函数环境中可以访问的变量的顺序：1.该函数环境中的变量 <strong>anotherColor</strong> ，2.全局环境的变量 <strong>color</strong>。 <img src="/img/scope5.jpg" alt="Alt text"> 在函数changeColor执行过程中又创建了函数swapColor，因此会为函数预先创建一个作用域链，和之前不一样的地方是除了window对象，该作用域链还包含了外部函数（changeColor）的活动对象。另插一句：这是闭包最本质的解释。</li>
<li>调用函数swapColor，会创建函数环境，并复制函数属性 <strong>[[Scope]]</strong> 来创建函数环境的作用域链，再创建函数环境本身的活动对象，并将该活动对象推入到作用域链的前端。 <img src="/img/scope6.jpg" alt="Alt text"> 这里就不再啰嗦整个过程了，相信前面多次的解释已经明白了如何创建作用域链。 因此在swapColor函数环境里，按照 <strong>标识符解析</strong> ，可访问变量的顺序：1.本函数环境（swapColor）的变量： <strong>tempColor</strong> ，2.外部函数（changeColor）的变量： <strong>anotherColor</strong> ， 3.全局环境的变量： <strong>color</strong> 。 </li>
</ol>
<p>上面很辛苦地把这个例子非常详细地解释了作用域链的形成，现在简单总结一下，这个例子一共涉及3个环境：全局环境，changeColor函数环境，swapColor函数环境。</p>
<ol>
<li>全局环境有一个变量 <strong>color</strong> 和一个函数 <strong>changeColor()</strong> ，但是该环境却不能访问另外两个函数环境中的变量；</li>
<li>changeColor环境有一个变量 <strong>anotherColor</strong> 和一个函数 <strong>swapColor()</strong> ，该环境可以访问全局环境的变量 <strong>color</strong> ， 因为全局环境在它的作用域链上，但是却不能访问 swapColor函数环境中的变量；</li>
<li>swapColor函数环境有一个变量 <strong>tempColor</strong> ，并且该环境既可以访问全局环境的变量，也可以访问changeColor函数环境的变量，因为这两个环境都在它的作用域链上。</li>
</ol>
<blockquote>
<p>总结：内部环境可以通过作用域链访问外部所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个环境。</p>
<p>我的话：要想访问一个变量，就要看该变量是否在当前环境的作用域链上。</p>
</blockquote>
<h2 id="函数表达式"><a href="#函数表达式" class="headerlink" title="函数表达式"></a>函数表达式</h2><p>在正式进入闭包之前，先来说一说函数表达式。之前花费了大量时间来解释作用域链，如果理解了作用域链， <strong>闭包可以看做是作用域链的副作用</strong> 。函数在JavaScript 中可以说是最重要的，我会专门写一篇文章来讨论《函数，JavaScript 的第一等公民》。这里只是介绍了函数的简单用法。</p>
<p>定义函数的方式：<strong>函数声明</strong> 和 <strong>函数表达式</strong> 。</p>
<h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>最基本的函数定义方式，关键是它有一个重要特征： <strong>函数声明提升</strong> ，执行代码之前会先读取函数声明，也就是可以先调用函数再声明函数，举个例子：</p>
<pre><code>sayHi();  // Hi!
function sayHi() {
  console.log(&apos;Hi!&apos;);
}
</code></pre><p>函数声明提升有好处也有坏处，有机会会说到，至于为什么会这样，关系到JavaScript 的词法解析，我们暂且记住：函数声明会出现函数声明提升。</p>
<h3 id="函数表达式-1"><a href="#函数表达式-1" class="headerlink" title="函数表达式"></a>函数表达式</h3><p>这应该是用的最多的函数定义的方式，上面的例子使用函数表达式后变成：</p>
<pre><code>var sayHi = function() {
  console.log(&apos;Hi!&apos;);
};
sayHi();  // Hi!
</code></pre><p>上面代码创建了一个函数并将它赋值给变量 <strong>sayHi</strong> ，这个创建的函数叫做 <strong>匿名函数</strong> （function后面没有标识符），并且函数表达式不再像函数声明那样具有函数声明提升的特征，在使用前必须先声明，因此下面代码会报错：</p>
<pre><code>sayHi();  // Uncaught TypeError: sayHi is not a function
var sayHi = function() {
  console.log(&apos;Hi!&apos;);
};
</code></pre><p>函数表达式能够先创建函数再赋值给变量，也能够把函数作为其他函数的值返回（做函数的返回值），下面这个例子将作为 <strong>闭包</strong> 的例子来解析。</p>
<pre><code>function createComparisonFunction(propertyName) {
  return function(object1, object2) {
    var value1 = object1[propertyName];
    var value2 = object2[propertyName];
    if(value1 &lt; value2) {
      return -1;
    } else if(value1 &gt; value2) {
      return 1;
    } else {
      return 0;
    }
  };
}
</code></pre><p>在这个函数（createComparisonFunction）里就返回了一个 <strong>匿名函数</strong> 。</p>
<blockquote>
<p>函数声明和函数表达式的区别：<strong>函数声明提升</strong> 会使得函数声明可以先使用再声明，但是函数表达式在使用前必须先赋值。</p>
</blockquote>
<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>终于开始提到闭包，但有了之前大量的铺垫，相信虽然这里才刚刚开始，不过也会很快就结束。</p>
<blockquote>
<p><strong>闭包</strong> ：有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<p>我会在写闭包的时候不间断地把作用域链牵扯进来，闭包的概念有两点需要记住：</p>
<ol>
<li>闭包是一个函数，不是理解成一种现象，它就是一个函数，只是具备一些不一样的特性；</li>
<li>闭包这个函数可以访问另一个函数作用域中的变量，为什么可以访问别的函数中的变量？还记得作用域链里最后一句话，<strong>要想访问一个变量，就要看该变量是否在当前环境的作用域链上</strong>，可以访问很简单，因为这个变量在当前函数环境的作用域链上。</li>
</ol>
<p>前面的那个例子，我们定义了函数createComparisonFunction，并返回了一个匿名函数。其中在匿名函数中，代码 <strong>var value1 = object1[propertyName]</strong> 访问了外部函数的变量 <strong>propertyName</strong> 。即使这个匿名函数被返回了，然后在别的地方被调用，但它仍然可以访问变量 <strong>propertyName</strong> ，因此我们可以说这个匿名函数就是一个闭包。 为什么函数createComparisonFunction执行完毕返回了匿名函数后，这个匿名函数在被调用时仍然可以访问函数createComparisonFunction中的变量 <strong>propertyName</strong> 。思路当然是从作用域链上考虑，我们来画作用域链示意图，这里先给出完整的代码：</p>
<pre><code>function createComparisonFunction(propertyName) {
  return function(object1, object2) {
    var value1 = object1[propertyName];
    var value2 = object2[propertyName];
    if(value1 &lt; value2) {
      return -1;
    } else if(value1 &gt; value2) {
      return 1;
    } else {
      return 0;
    }
  };
}
var compareNames = createComparisonFunction(&apos;name&apos;);
var result = compareNames({name: &apos;Tom&apos;}, {name: &apos;Jerry&apos;});
console.log(result);  // 1
</code></pre><ol>
<li>全局环境定义了一个函数 <strong>createComparisonFunction</strong> 和两个变量 <strong>compareNames</strong> ， <strong>result</strong> ，它们都保存在window对象上。并且在创建函数 <strong>createComparisonFunction</strong> 时会预先创建一个包含window对象的作用域链，保存在该函数的内部属性 <strong>[[Scope]]</strong> 上。 <img src="/img/scope7.jpg" alt="Alt text"> </li>
<li>调用函数 <strong>createComparisonFunction</strong> ，会创建一个函数环境，并复制函数的内部属性创建环境的作用域链，再创建环境的活动对象（arguments对象，参数propertyName），最后将这个活动对象推入到作用域链的前端。 <img src="/img/scope8.jpg" alt="Alt text"> </li>
<li>函数 <strong>createComparisonFunction</strong> 在执行过程中返回了一个匿名函数，同样会为该匿名函数预先创建一个作用域链，除了包含window对象还包括外部函数环境（createComparisonFunction）的活动对象。 <img src="/img/scope9.jpg" alt="Alt text"> </li>
<li>函数 <strong>createComparisonFunction</strong> 执行完成后，返回的匿名函数被赋值给变量 <strong>compareNames</strong> ，再调用这个匿名函数，同样会创建一个函数环境，复制函数的内部属性创建环境的作用域链，再创建环境的活动对象（arguments对象，参数object1，object2），并推入到作用域链的前端。 <img src="/img/scope10.jpg" alt="Alt text"> </li>
</ol>
<blockquote>
<p>匿名函数从函数 <strong>createComparisonFunction</strong> 中返回后，它的作用域链被初始化为包含 <strong>createComparisonFunction</strong> 环境的活动对象和window对象。这样匿名函数就可以访问在 <strong>createComparisonFunction</strong> 中定义的所有变量。 最重要的是： <strong>createComparisonFunction</strong> 函数在执行完毕后，其活动对象也不会被销毁，因为匿名函数的作用域链仍然在引用这个活动对象。也就是说，当 <strong>createComparisonFunction</strong> 函数返回后，其执行环境的作用域链会被销毁，但它的活动对象仍然会留在内存中，直到匿名函数被销毁后， <strong>createComparisonFunction</strong> 的活动对象才会被销毁。</p>
</blockquote>
<p>上面一段话，总结起来就是 <strong>闭包的作用域链包含了外部函数的活动对象</strong> ，即使外部函数执行完毕，函数环境的作用域链被销毁，但它的活动对象由于闭包仍然存在于内存中。</p>
<p>由于闭包会携带外部函数的作用域（外部函数的活动对象），因此会占用较多的内存，因此需要慎用闭包。上面的例子，匿名函数的作用域链就包含了外部函数 <strong>**createComparisonFunction</strong> 的活动对象，因此如果明确知道不再使用该匿名函数就需要手动解除引用，像下面这样：</p>
<pre><code>// 解除匿名函数的引用（以便垃圾收集器回收内存）
compareNames = null;
</code></pre><p>至此，关于闭包的理解应该算是比较深入了，后面还会继续补充关于闭包的使用（闭包可以做什么），将放在另一篇文章。</p>
<p>第一稿于2017.10.7</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/05/closure/" data-id="cj8imchlm0007e6jxejmyqah0" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-garbage-collection" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/05/garbage-collection/" class="article-date">
  <time datetime="2017-10-05T02:09:29.000Z" itemprop="datePublished">2017-10-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/05/garbage-collection/">JavaScript 的垃圾收集</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <blockquote>
<p>JavaScript 具有自动垃圾收集机制：找出那些不再继续使用的变量，释放其占用的内存，并且来及收集器会按照固定的时间间隔周期性地执行这一操作。</p>
</blockquote>
<p>JavaScript 具备自动垃圾收集的功能，不用再关心内存的使用问题，比如分配、使用和回收内存。这对程序员来说很方便，但是如果随意使用的话，很容易出现内存泄漏的问题，所以还是有必要去了解JavaScript 的垃圾收集机制，在我们写代码的时候注意一些规范可以避免内存泄漏的问题。</p>
<h2 id="标记清除，最常用的垃圾收集方式"><a href="#标记清除，最常用的垃圾收集方式" class="headerlink" title="标记清除，最常用的垃圾收集方式"></a>标记清除，最常用的垃圾收集方式</h2><p>该方式很容易理解，变量进入环境（函数里定义变量），就将该变量标记为“<strong>进入环境</strong>”，进入环境的变量其占用的内存是不能被释放的。变量离开环境（函数执行完成），则将其标记为“<strong>离开环境</strong>”。对于那些“离开环境”的变量，环境已经无法访问到，由垃圾收集器来完成内存清除工作，释放这些变量占用的内存。</p>
<p>目前大多数浏览器仍然支持该方式，不同的是垃圾收集的间隔不一样。</p>
<h2 id="引用计数，不太常用，是将来趋势"><a href="#引用计数，不太常用，是将来趋势" class="headerlink" title="引用计数，不太常用，是将来趋势"></a>引用计数，不太常用，是将来趋势</h2><p>该方式比前一种复杂，问题也比较多，但是它有一定的好处。<strong>引用计数的含义：跟踪记录每个值被引用的次数。</strong> 声明一个变量，并且将引用类型的值赋给该变量，这个引用类型的值的引用次数就是1。如果该值又赋给了另一个变量，则该值的引用次数加1 。如果包含该值的变量取了别的值，则引用次数减1 。如果该引用类型的值的引用次数为0， 说明没有办法再访问这个值了，其占用的内存就需要被释放回收了。等到垃圾收集器下一次运行的时候，就会来释放这些引用次数为0的值所占用的内存。举个例子：</p>
<pre><code>// 声明变量为一个对象，该对象的引用次数为1
var obj1 = {key1: &apos;value1&apos;};
// 该对象又赋给另一个变量，引用次数加1等于2
var obj2 = obj1;
console.log(obj1, obj2);
// 包含对象的变量取得了另一个值，引用次数减1
obj1 = null;                  // 引用次数为1
obj2 = null;                  // 引用次数为0
// 引用次数为0，该对象已经无法访问到，回收其占用内存
console.log(obj1, obj2);
</code></pre><p>上面的例子注释写得很清楚了，当下一次垃圾收集器运行时，对象占用的内存就会被释放。现在看来引用计数的方式还是很不错的，不过当出现下面的情况时，问题就来了，还比较严重：</p>
<pre><code>function problem() {
  // 这两个对象的引用次数在声明时，都是1
  var obj1 = new Object();
  var obj2 = new Object();
  // 这两个对象又被赋给了别的变量（对象的属性），引用次数加1等于2
  obj1.someObj = obj2;
  obj2.anotherObj = obj1;
  console.log(obj1, obj2);
}
</code></pre><p>上面的例子，是一个很严重的bug，叫做“<strong>循环引用</strong>”。打印obj1和obj2的值，它们的值会循环使用这两个对象的值，你引用我，我引用你，你再引用我，一直重复下去。对于这两个对象，如果采用标记清除的方式，没有任何问题，函数执行完成，这两个对象离开了函数作用域，标记为“离开环境”，自然垃圾收集器会自动来释放它们占用的内存。但是如果是引用计数的方式的话，可以看到即使函数执行完成，obj1和obj2还是存在的，因为它们的引用计数是2，这两个对象永远不会被回收，这里内存就发生泄漏了。</p>
<p>只要存在循环引用，则引用类型的值的引用次数就永远不会变成0，自然也就不会被释放，就会产生内存泄漏。解决这样的问题，就需要我们手动地来解除引用，在我们不再使用这些值的时候。常用的解除方式就是变量的值设为null，这就切断了变量和它之前引用的值之间的联系，使得引用次数可以变成0，这样就会被垃圾收集器回收，上面的例子可以这样解除：</p>
<pre><code>// 不再需要使用这两个对象的时候
obj1.someObj = null;
obj2.anotherObj = null;
console.log(obj1, obj2);
</code></pre><h2 id="管理内存，为全局变量和全局对象的属性解除引用"><a href="#管理内存，为全局变量和全局对象的属性解除引用" class="headerlink" title="管理内存，为全局变量和全局对象的属性解除引用"></a>管理内存，为全局变量和全局对象的属性解除引用</h2><p>这不是垃圾收集的方式，而是我们平时写代码的一种规范。JavaScript 虽然具备自动垃圾收集机制，但这并不意味着我们可以随意使用变量，因为分配给浏览器的内存会有一定的限制，因此需要我们用最少的内存让页面获得更好的性能。最佳方式就是“<strong>解除引用</strong>”，当变量不再使用的时候，将其设为null来释放其引用，主要是来释放大多数全局变量和全局对象的属性。局部变量会在离开环境时自动被解除引用。下面的这个例子就详细说明了如何来解除引用：</p>
<pre><code>function createPerson(name) {
  var localPerson = new Object();
  localPerson.name = name;
  return localPerson;
}
var globalPerson = createPerson(&apos;Test&apos;);
console.log(globalPerson);
// 不再使用变量时手工解除globalPerson的引用
globalPerson = null;
</code></pre><p>在上面的例子中，首先看到的是局部变量localPerson在函数执行完毕后，就离开了执行环境，它会自动解除引用，无需我们显式地为它去解除（默认执行了localPerson=null）。但是对于全局变量globalPerson，则需要我们不再使用它的时候为它手工解除引用，将其值设为null。解除引用的真正作用是让值脱离执行环境，使得垃圾收集器下次运行时可以把它们进行回收。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><p>之前一直在提内存泄漏，其实就是分配的内存无法对它进行回收，之前说过了一种情况，如果出现循环引用，则变量的引用次数永远不会变成0，这样改变量也就永远不会被回收。这里再具体说一种内存泄漏的情况，以及如何消除这种情况。还是先看一个内存泄漏的例子，也是我们平常经常会写的例子。</p>
<pre><code>function assignHandle() {
  var btn = document.getElementById(&apos;myBtn&apos;);
  btn.onclick = function () {
    console.log(btn.id);
  };
}
</code></pre><p>上面的例子，创建了一个作为btn元素事件处理程序（函数）的闭包，匿名函数（事件处理程序）保存了对assignHandle()的活动对象的引用，因此就会导致无法减少btn的引用次数。匿名函数始终存在，btn的引用次数不会变成0 ，因此btn所占用的内存就永远不会被回收，这就造成了内存泄漏。</p>
<p>上面的解释涉及了闭包，其实内存泄漏的根源就是闭包，但是不是所有闭包都会造成内存泄漏，但是内存泄漏一定和闭包有关。闭包的根源是JavaScript 的作用域链，关于闭包可以看另一篇文章《闭包，从作用域链说起》。这里不解释闭包，但是发生了内存泄漏是显然可以看见的，变量btn永远不会被回收。想要解决这样的问题，就可以用之前的方法，使用<strong>解除引用</strong>。再看下面的代码：</p>
<pre><code>function assignHandle() {
  var btn = document.getElementById(&apos;myBtn&apos;);
  var id = btn.id;
  btn.onclick = function () {
    console.log(id);
  };
  btn = null;
}
</code></pre><p>和上面的例子的区别：创建btn.id的一个副本保存在一个变量中，在闭包中引用该变量就消除了循环引用。另外闭包会引用包含函数的整个活动对象，这里就是匿名函数（事件处理程序）引用了assignHandle()的整个活动对象，其中包含着btn变量。即使闭包没有直接使用btn变量，包含函数的活动对象也仍然会保存一个引用。这里就是说即使匿名函数（事件处理程序）没有直接使用变量btn，但是assignHandle()的活动对象中的变量btn仍然会保存一个引用。因此还是会出现内存泄漏的情况，只要匿名函数存在，assignHandle()的活动对象的变量btn的引用次数都不会变成0 。要想解除引用的话也很简单，手动将其值设为null即可，这样就能解除对DOM对象的引用，引用次数就会变成0 ，被垃圾收集器回收。</p>
<blockquote>
<p>总结：这一部分内容主要围绕了JavaScript 的垃圾收集机制，也探讨了内存管理和内存泄漏。虽然JavaScript 不像其他语言那样需要手动管理内存，但是仍然需要我们关注，用最少的内存提升页面的性能。这里面背后蕴含了JavaScript 最基本也是最深刻的知识，闭包来源于作用域链，这是JavaScript 两大链之一（作用域链和原型链），是JavaScript 程序员提升自己能力的必走之路。</p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/05/garbage-collection/" data-id="cj8imchlo0008e6jxw61kczvw" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-array" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/02/JS-array/" class="article-date">
  <time datetime="2017-10-02T01:40:54.000Z" itemprop="datePublished">2017-10-02</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/02/JS-array/">JavaScript 的数组汇总</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>该文章会不断更新…</p>
<h2 id="数组的操作方法"><a href="#数组的操作方法" class="headerlink" title="数组的操作方法"></a>数组的操作方法</h2><p>数组的内容比较多，一次性也写不完，先写三个操作方法，concat()，slice()，splice()。前面两个方法有一些共性：<strong>1.返回一个新的数组；2.不会改变原数组</strong>。第三个方法是在原数组的基础上进行操作，会改变原来的数组。</p>
<h3 id="concat方法，数组拼接，不改变原数组"><a href="#concat方法，数组拼接，不改变原数组" class="headerlink" title="concat方法，数组拼接，不改变原数组"></a>concat方法，数组拼接，不改变原数组</h3><p>这个方法会先创建当前数组的一个副本（为了不影响原数组），然后将接受到的参数添加到这个副本的末尾，最后返回新构建的数组。</p>
<h4 id="第一种情况：concat方法没有参数，只是复制当前数组并返回副本"><a href="#第一种情况：concat方法没有参数，只是复制当前数组并返回副本" class="headerlink" title="第一种情况：concat方法没有参数，只是复制当前数组并返回副本"></a>第一种情况：concat方法没有参数，只是复制当前数组并返回副本</h4><pre><code>var colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];
var colors2 = colors.concat();
console.log(colors);      // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]
console.log(colors2);            // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]
colors2.push(&apos;black&apos;);
console.log(colors);            // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]
console.log(colors2);            // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]
</code></pre><p>上面的例子，concat方法没有传入参数，并且为了证明concat方法返回的是一个副本，colors2数组添加了一个元素，结果原来的数组没有改变。</p>
<h4 id="第二种情况：参数是一个或多个数组，数组的每一项都添加到数组中"><a href="#第二种情况：参数是一个或多个数组，数组的每一项都添加到数组中" class="headerlink" title="第二种情况：参数是一个或多个数组，数组的每一项都添加到数组中"></a>第二种情况：参数是一个或多个数组，数组的每一项都添加到数组中</h4><h4 id="第三种情况：参数不是数组，值就会被简单地加到数组的末尾"><a href="#第三种情况：参数不是数组，值就会被简单地加到数组的末尾" class="headerlink" title="第三种情况：参数不是数组，值就会被简单地加到数组的末尾"></a>第三种情况：参数不是数组，值就会被简单地加到数组的末尾</h4><pre><code>var colors = [&apos;red&apos;, &apos;blue&apos;, &apos;green&apos;];
var colors2 = colors.concat([&apos;white&apos;, &apos;black&apos;], &apos;pink&apos;);
console.log(colors);  //  [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]
console.log(colors2);  // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;]
</code></pre><h3 id="slice方法，数组分割，不改变原数组"><a href="#slice方法，数组分割，不改变原数组" class="headerlink" title="slice方法，数组分割，不改变原数组"></a>slice方法，数组分割，不改变原数组</h3><p>基于当前数组中的一个或多个元素创建一个新数组。</p>
<h4 id="第一种情况：只有一个参数，从该参数指定位置到数组末尾的所有元素。"><a href="#第一种情况：只有一个参数，从该参数指定位置到数组末尾的所有元素。" class="headerlink" title="第一种情况：只有一个参数，从该参数指定位置到数组末尾的所有元素。"></a>第一种情况：只有一个参数，从该参数指定位置到数组末尾的所有元素。</h4><h4 id="第二种情况：两个参数，起始到结束位置的所有元素，不包括结束位置的元素。"><a href="#第二种情况：两个参数，起始到结束位置的所有元素，不包括结束位置的元素。" class="headerlink" title="第二种情况：两个参数，起始到结束位置的所有元素，不包括结束位置的元素。"></a>第二种情况：两个参数，起始到结束位置的所有元素，不包括结束位置的元素。</h4><pre><code>var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;];
var colors1 = colors.slice(2);
var colors2 = colors.slice(2, 5);
console.log(colors);  // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;]
console.log(colors1);  // [&quot;green&quot;, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;]
console.log(colors2);  // [&quot;green&quot;, &quot;white&quot;, &quot;black&quot;]
</code></pre><p>注意：参数是负数的话，就加上数组长度变成正数，如果结束位置小于起始位置，返回空数组。</p>
<h3 id="splice方法，什么都能做，会改变原数组"><a href="#splice方法，什么都能做，会改变原数组" class="headerlink" title="splice方法，什么都能做，会改变原数组"></a>splice方法，什么都能做，会改变原数组</h3><p>这个方法很强大，也很灵活，拼接和分割可以用前面的方法，如果是要替换呢？这个方法能做前面两种活，还能做替换，一一详细说明。</p>
<h4 id="删除，两个参数，第一个表示起始位置，第二个表示删除的个数"><a href="#删除，两个参数，第一个表示起始位置，第二个表示删除的个数" class="headerlink" title="删除，两个参数，第一个表示起始位置，第二个表示删除的个数"></a>删除，两个参数，第一个表示起始位置，第二个表示删除的个数</h4><pre><code>var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;];
// 从第一个位置开始删除2个元素
var remove = colors.splice(1, 2);
console.log(colors);  // [&quot;red&quot;, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;]
console.log(remove);  // [&quot;blue&quot;, &quot;green&quot;]
</code></pre><p>该方法是直接在原数组上进行操作，方法结束后原来的数组发生改变，返回的是操作的结果。上面的例子，原来的数组少了两个元素，返回的结果就是被删除的那两个元素。</p>
<h4 id="插入，三个参数，第一个表示起始位置，第二个位0，表示不删除元素，第三个元素为插入的元素（可以多个）"><a href="#插入，三个参数，第一个表示起始位置，第二个位0，表示不删除元素，第三个元素为插入的元素（可以多个）" class="headerlink" title="插入，三个参数，第一个表示起始位置，第二个位0，表示不删除元素，第三个元素为插入的元素（可以多个）"></a>插入，三个参数，第一个表示起始位置，第二个位0，表示不删除元素，第三个元素为插入的元素（可以多个）</h4><pre><code>var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
// 从第一个位置开始插入3个元素
var remove = colors.splice(1, 0, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;);
console.log(colors);  // [&quot;red&quot;, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;, &quot;blue&quot;, &quot;green&quot;]
console.log(remove);  // []
</code></pre><p>由于没有删除元素，该方法返回一个空数组。</p>
<h4 id="替换，三个参数，第一个起始位置，第二个删除元素个数，第三个为替换的元素（可以多个）"><a href="#替换，三个参数，第一个起始位置，第二个删除元素个数，第三个为替换的元素（可以多个）" class="headerlink" title="替换，三个参数，第一个起始位置，第二个删除元素个数，第三个为替换的元素（可以多个）"></a>替换，三个参数，第一个起始位置，第二个删除元素个数，第三个为替换的元素（可以多个）</h4><pre><code>var colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];
// 从第一个位置删除一个元素，在添加3个元素
var remove = colors.splice(1, 1, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;);
console.log(colors);  // [&quot;red&quot;, &quot;white&quot;, &quot;black&quot;, &quot;pink&quot;, &quot;green&quot;]
console.log(remove);  // [&quot;blue&quot;]
</code></pre><p>由于删除了第一个位置上的元素，返回了删除的元素。</p>
<blockquote>
<p>总结：concat（拼接）和slice（分割）方法返回了一个新数组，不会改变原数组，splice方法很灵活，但是它是在原数组上进行操作，会改变原数组，返回的是一个数组包含的是从原数组中删除的元素。</p>
</blockquote>
<p>第一稿于2017-10-2</p>
<hr>
<h2 id="检测数组"><a href="#检测数组" class="headerlink" title="检测数组"></a>检测数组</h2><p>我们知道JavaScript 的数据类型里面是没有数组类型的，使用操作符 <strong>typeof</strong> 得到的是 object。</p>
<pre><code>var arr = [1, 2, 3];
console.log(typeof arr); // object
</code></pre><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>如果想要明确某个对象是数组的话，对于只有一个全局作用域的话，可以使用 <strong>instanceof</strong> 来判断。</p>
<pre><code>var arr = [1, 2, 3];
console.log(arr instanceof Array); // true
</code></pre><p>该方法的问题，只能有一个全局环境，暂时不理解这有什么问题。</p>
<h3 id="isArray"><a href="#isArray" class="headerlink" title="isArray"></a>isArray</h3><p>使用方法 <strong>Array.isArray()</strong> ,该方法不管数组是在哪个全局环境中创建的。</p>
<pre><code>var arr = [1, 2, 3];
console.log(Array.isArray(arr)); // true
</code></pre><p>第二稿于2017-10-7</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/02/JS-array/" data-id="cj8imchli0004e6jxw8pbbj5x" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-Event-performance" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/01/JS-Event-performance/" class="article-date">
  <time datetime="2017-10-01T02:41:08.000Z" itemprop="datePublished">2017-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/01/JS-Event-performance/">事件的性能</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>性能是一个重要的话题，特别是在JavaScript语言中，JS是单线程执行任务的。如果性能不好的话，很容易引起用户感觉上的不适，页面加载很慢，点击没反应之类的问题。这里主要是从事件处理程序上来说明性能的问题。</p>
<ol>
<li><p>事件处理程序是一个函数，JS里函数也是对象，需要占用内存，事件处理程序太多也就会导致占用的内存越多，性能也就越差，所以需要控制事件处理程序的数量。</p>
</li>
<li><p>事件处理程序需要添加在指定的元素上，而DOM操作是非常耗时的，事件处理程序越多，DOM访问次数也越多，这样会影响页面的交互性能，会有迟钝的感觉。</p>
</li>
</ol>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件处理程序过多的问题，需要考虑<strong>事件委托</strong>。原理也很简单，利用了事件冒泡。一个事件处理程序可以管理某一类型的所有事件。以下面这个例子来说明：</p>
<pre><code>&lt;ul id=&quot;links&quot;&gt;
  &lt;li id=&quot;link1&quot;&gt;link1&lt;/li&gt;
  &lt;li id=&quot;link2&quot;&gt;link2&lt;/li&gt;
  &lt;li id=&quot;link3&quot;&gt;link3&lt;/li&gt;
&lt;/ul&gt;
</code></pre><p>3个li元素被点击后会执行相应的操作，传统的做法是给每一个li元素都添加事件处理程序，像下面这样：</p>
<pre><code>var item1 = document.getElementById(&apos;link1&apos;);
var item2 = document.getElementById(&apos;link2&apos;);
var item3 = document.getElementById(&apos;link3&apos;);

EventUtil.addHandler(item1, &apos;click&apos;, function(event){
  console.log(&apos;Link 1.&apos;);
});
EventUtil.addHandler(item2, &apos;click&apos;, function(event){
  console.log(&apos;Link 2&apos;);
});
EventUtil.addHandler(item3, &apos;click&apos;, function(event){
  console.log(&apos;Link 3.&apos;);
});
</code></pre><p>上面代码使用了自己封装的跨浏览器的事件处理程序对象（在事件处理程序的那篇博客里有），这样添加的话，需要为每一个元素都添加，如果需要添加的元素很多的话，必然会有很多事件处理程序，占用内存越多性能越差。所以上面的例子完全可以使用事件委托，在DOM树上层次尽量高的地方添加一个就好了，这里就选ul元素。</p>
<pre><code>var list = document.getElementById(&apos;links&apos;);
EventUtil.addHandler(list, &apos;click&apos;, function(event) {
  var target = event.target;
  switch(target.id) {
    case &apos;link1&apos;:
      console.log(&apos;Link 1.&apos;);
      break;
    case &apos;link2&apos;:
      console.log(&apos;Link 2.&apos;);
      break;
    case &apos;link3&apos;:
      console.log(&apos;Link 3.&apos;);
      break;
    default:
      break;
  }
});
</code></pre><p>很明显使用了事件委托，只取得了一个DOM元素，只添加了一个事件处理程序，因为利用了事件冒泡的特性。适合事件委托的事件主要是鼠标（click，mousedown，mouseup）和键盘事件（keydown，keyup，keypress）。</p>
<blockquote>
<p>总结：事件委托将一类的事件处理程序减少为一个，利用了事件冒泡的特性，有效地提升了页面的性能。主要体现在两个方面：1.减少DOM的访问次数；2.减少事件处理程序的数量。</p>
</blockquote>
<h2 id="移除事件处理程序"><a href="#移除事件处理程序" class="headerlink" title="移除事件处理程序"></a>移除事件处理程序</h2><p>上面说了使用事件委托是从数量上来限制事件处理程序带来的性能影响。但如果事件处理程序不需要的话，不及时清除的话，内存里留有那些“空事件处理程序”， 也会造成内存和性能的问题。说简单点，就是不需要的时候及时移除事件处理程序。</p>
<h3 id="第一种情况：-文档中移除带有事件处理程序的元素"><a href="#第一种情况：-文档中移除带有事件处理程序的元素" class="headerlink" title="第一种情况： 文档中移除带有事件处理程序的元素"></a>第一种情况： 文档中移除带有事件处理程序的元素</h3><p>这也很好理解，一开始有一个元素，给它添加了一个事件处理程序，然后在别的地方这个元素被移除了（可以是DOM操作，也可以是使用innerHTML直接替换），反正这个元素不再出现在页面上，自然添加在这个元素上的事件处理程序也不会再被执行，这样就变成了“空事件处理程序”。浏览器不会那么智能（最傻的IE），它可不知道这个事件处理程序已经变成了空事件，也就不会把它当做垃圾进行回收，因为事件处理程序程序和元素还保存着引用关系。（这里关于垃圾收集机制不具体解释，有一个方式是引用计数，只要一个对象还保存着引用关系就不会被当做垃圾回收）。既然浏览器不智能，那就我们手动来做这件事，手工移除事件处理程序，这样该事件处理程序的引用次数变成0，会被当做垃圾进行回收。下面的例子就解释了之前说的这么一大段话。</p>
<pre><code>&lt;div id=&quot;myDiv&quot;&gt;
  &lt;button id=&quot;myBtn&quot;&gt;Click&lt;/button&gt;
&lt;/div&gt;

var btn = document.getElementById(&apos;myBtn&apos;);
    btn.onclick = function() {
        document.getElementById(&apos;myDiv&apos;).innerHTML = &apos;change div.&apos;;
    };
</code></pre><p>上面的例子也很简单，单击button元素，整个div元素就变成了一段文字“change div.”，button元素被替换了，不再在页面上出现，但是事件处理程序和这个button元素还保存着引用关系，只要还存在着这样的引用关系，浏览器就不会把它们当做是垃圾进行回收，没有用了还放在内存里面，这不就是浪费了吗？所以在移除元素或者替换的时候，最好手动去移除事件处理程序（虽然有些浏览器现在比较聪明了，但是IE还是那么傻），针对上面的例子使用的是DOM 0级方法添加的，移除的话就是属性值设为null。</p>
<pre><code>var btn = document.getElementById(&apos;myBtn&apos;);
btn.onclick = function() {
  // 明确某个元素会被移除，手动移除事件处理程序
  btn.onclick = null;
  document.getElementById(&apos;myDiv&apos;).innerHTML = &apos;change div.&apos;;
};
</code></pre><h2 id="第二种情况：页面卸载"><a href="#第二种情况：页面卸载" class="headerlink" title="第二种情况：页面卸载"></a>第二种情况：页面卸载</h2><p>很多浏览器（尤其是IE）在页面卸载的时候，如果没有把事件处理程序清除干净，那这些剩余的就会滞留在内存中。这样在下次装载或者刷新的时候，它们还存在在内存中，导致内存滞留的对象越来越多，就是因为事件处理程序占用的空间没有被释放。</p>
<p>解决办法其实已经说了，<strong>在onunload事件（页面卸载事件）里面移除所有的事件处理程序</strong>。如果你使用了事件委托，那很庆幸，这里去移除事件处理程序会很简单，否则的话你要为每一个事件事件处理程序都要写相应的移除处理代码。简单的话，就是在onload事件里添加的内容，需要在onunload事件里相应地去移除。</p>
<blockquote>
<p>总结：移除事件处理程序，也会提升页面的性能。第一种情况：在知道元素被移除的时候需要手动去移除事件处理程序；第二种情况：在页面卸载的时候移除所有事件处理程序。</p>
</blockquote>
<p>第一稿于2017.10.2</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/01/JS-Event-performance/" data-id="cj8imchle0002e6jxntl9ehev" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JS-Event" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/01/JS-Event/" class="article-date">
  <time datetime="2017-10-01T00:25:26.000Z" itemprop="datePublished">2017-10-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/01/JS-Event/">事件处理程序</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <ol>
<li><p>HTML事件处理程序（没人用了）；</p>
</li>
<li><p>DOM 0级事件处理程序，每一个事件只支持一个事件处理程序；</p>
</li>
<li><p>IE事件处理程序（看见IE就烦）；</p>
</li>
<li><p>DOM 2级事件处理程序（默认使用）。</p>
</li>
</ol>
<p>既然事件处理程序有这么多类型，自然考虑要封装一下，写一个<strong>跨浏览器的事件处理程序</strong>，以上三种方式（第一种不考虑）的优先级：先判断DOM 2级方法，再判断IE方法，最后是DOM 0级方法。</p>
<h2 id="跨浏览器的事件处理程序"><a href="#跨浏览器的事件处理程序" class="headerlink" title="跨浏览器的事件处理程序"></a>跨浏览器的事件处理程序</h2><p>直接上代码，来源于红宝书。</p>
<pre><code>var EventUtil = {
  // 添加事件处理程序
  addHandler: function(element, type, handler) {
    // 先判断DOM 2级方法
    if(element.addEventListener) {
      // false 表示冒泡阶段调用事件处理程序
      element.addEventListener(type, handler, false);
    }
    // 再判断IE方法
    else if(element.attachEvent) {
      // IE方法，事件类型需要加上前缀‘on’
      element.attachEvent(&apos;on&apos;+type, handler);
    }
    // 最后判断DOM 0级方法，一个事件只支持一个事件处理程序
    else {
      element[&apos;on&apos;+type] = handler;
    }
  },
  // 移除事件处理程序
  removeHandler: function(element, type, handler) {
    if(element.removeEventListener) {
      element.removeEventListener(type, handler, false);
    } else if(element.detachEvent) {
      element.detachEvent(&apos;on&apos;+type, handler);
    } else {
      element[&apos;on&apos;+type] = null;
    }
  }
};
</code></pre><p>以上代码可以作为跨浏览器的事件处理程序，添加事件处理程序如下：</p>
<pre><code>var btn = document.getElementById(&apos;myBtn&apos;);
var handler = function() {
  console.log(&apos;Clicked.&apos;);
};
EventUtil.addHandler(btn, &apos;click&apos;, handler);
</code></pre><p>给button元素的‘click’事件添加了一个事件处理程序，点击button会打印‘Clicked.’，移除事件处理程序如下：</p>
<pre><code>EventUtil.removeHandler(btn, &apos;click&apos;, handler);
</code></pre><p>以上代码运行在chorme浏览器，添加和移除事件处理程序都是使用<strong>DOM 2级方法</strong>。IE浏览器8以上也是用DOM 2级方法，8以下（包括8）使用的是IE方法（亲测）。下面就回过头来仔细说说前面几种不同的方法。</p>
<h2 id="DOM-2级事件处理程序"><a href="#DOM-2级事件处理程序" class="headerlink" title="DOM 2级事件处理程序"></a>DOM 2级事件处理程序</h2><p>我先说DOM 2级方法，是因为目前基本上都是用它来添加或移除事件处理程序。其实就定义了两个方法<strong>addEventListener()和removeEventListener()</strong>。每个DOM节点都有这两个方法，接受三个参数（事件名称，事件处理程序函数，布尔值false）。最后一个参数推荐false表示在冒泡阶段调用事件处理程序（为了兼容浏览器，大多数情况，事件处理程序会被添加到事件流的冒泡阶段）。还是之前的例子，这里只展示用DOM 2级方法来添加、移除事件处理程序。</p>
<pre><code>var btn = document.getElementById(&apos;myBtn&apos;);
var handler1 = function() {
  console.log(&apos;Clicked 1.&apos;);
};
var handler2 = function() {
  console.log(&apos;Clicked 2.&apos;);
};
// 参数：事件名称，事件处理程序函数，false表示冒泡阶段执行函数
btn.addEventListener(&apos;click&apos;, handler1, false);
btn.addEventListener(&apos;click&apos;, handler2, false);
</code></pre><p>以上代码为button元素的‘click’事件添加了事件处理程序，该事件在冒泡阶段触发。并且DOM 2级方法有一个明显的好处，就是<strong>可以在一个事件上添加多个事件处理程序</strong>，并且在执行时会按照添加的顺序执行。上面的例子，依次添加了事件处理程序handler1和hendler2，因此在点击button元素后会依次打印‘Clicked 1.’，‘Clicked 2.’。</p>
<p>使用DOM 2级方法addEventListener()添加的事件处理程序，也必须用DOM 2级方法removeEventListener()来移除。并且传入的参数必须一致，所以添加的时候，<strong>传入了一个匿名函数，该事件处理程序将无法被移除</strong>。因此不要使用匿名函数，可以使用函数定义或函数表达式来显式把函数名来传参，这样在移除的时候就知道是哪一个函数被添加进来了。比如需要移除上面例子的第一个事件处理程序。</p>
<pre><code>btn.removeEventListener(&apos;click&apos;, handler1, false);
</code></pre><p>添加上面代码后，再次点击button元素，只有第二个事件处理程序会被执行，只会打印‘Clicked 2.’，说明第一个事件处理程序成功被移除。</p>
<blockquote>
<p>总结：1.两个方法addEventListener()和removeEventListener()； 2.一个事件支持多个事件处理程序； 3.添加和移除的事件处理程序必须是一样的，显式传入函数名。</p>
</blockquote>
<h2 id="IE事件处理程序"><a href="#IE事件处理程序" class="headerlink" title="IE事件处理程序"></a>IE事件处理程序</h2><p>不想写，没有什么意思，目前该方法会在IE浏览器8以下（包括8）才会被使用。它和DOM 2级方法类似，也定义了两个方法attachEvent()和detachEvent()（起的什么名字）。这两个方法和DOM 2级的两个方法功能是一样的，不过它只有两个参数，因为事件冒泡是IE提出的，所以在IE8之前，IE只支持事件冒泡，也就不存在捕获阶段。以下代码需要在IE浏览器8之前版本（包括8）上运行：</p>
<pre><code>var btn = document.getElementById(&apos;myBtn&apos;);
var handler1 = function() {
  console.log(&apos;Clicked 1.&apos;);
};
var handler2 = function() {
  console.log(&apos;Clicked 2.&apos;);
};

btn.attachEvent(&apos;onclick&apos;, handler1);
btn.attachEvent(&apos;onclick&apos;, handler2);
</code></pre><p>以上代码同样是为button元素的‘click’事件添加事件处理程序，同样一个事件支持多个事件处理程序，奇葩的是，执行的顺序不是按照添加的顺序，而刚刚相反。点击button元素，先打印‘Clicked 2.’，再打印‘Clicked 1.’。这一现象需要在IE浏览器8之前看到，之后改过来了（亲测）。原来的真不知道是怎么想的，IE的东西就是这样奇葩，当然还有更奇葩的地方，默认情况下事件处理程序会在元素的作用域里执行，即this指向事件触发的元素，IE里事件处理程序是在全局作用域里执行，this指向window，这不是反逻辑吗？看下面的例子：</p>
<pre><code>var btn = document.getElementById(&apos;myBtn&apos;);
var handler = function() {
  console.log(this === window);
};
btn.attachEvent(&apos;onclick&apos;, handler);
</code></pre><p>点击button元素，打印的是‘true’，说明在事件处理程序里this指向的是window。</p>
<blockquote>
<p>总结：1.两个方法attachEvent()和detachEvent()，只在冒泡阶段执行；2. 一个事件支持多个事件处理程序，奇葩的是顺序和添加的顺序相反；3.添加和移除的事件处理程序函数是一样的，和DOM 2级方法一致；4. 最后就是IE的事件处理程序的作用域是全局作用域，this指向window。</p>
</blockquote>
<h2 id="DOM-0级事件处理程序"><a href="#DOM-0级事件处理程序" class="headerlink" title="DOM 0级事件处理程序"></a>DOM 0级事件处理程序</h2><p>只支持DOM 0级方法的浏览器没有多少了，也没什么可以说的。添加事件处理程序就是给把一个函数赋值给一个事件处理程序属性，移除的话就是属性值设为null。另外一点就是DOM 0级方法的每个事件只支持一个事件处理程序。也写一个例子：</p>
<pre><code>var btn = document.getElementById(&apos;myBtn&apos;);
btn.onclick = function() {
  console.log(&apos;My id is &apos;+this.id);
};
</code></pre><p>不像前面两种方式，有专门的方法来添加和移除事件处理程序，这里是直接给事件处理程序属性赋值一个函数，代表添加了一个事件处理程序。结果是打印‘My id is myBtn’，从语法上感觉事件处理程序就是元素的一个方法，因此事件处理程序是在元素的作用域里运行，this指向触发事件的当前元素。移除事件处理程序只要给属性值设为null。</p>
<pre><code>btn.onclick = null;
</code></pre><blockquote>
<p>总结：1.事件处理程序作为元素的方法，赋给事件处理程序属性；2.时间处理程序在元素的作用域里运行，this指向当前元素； 3.一个事件只支持一个事件处理程序。</p>
</blockquote>
<h2 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h2><p>不写了，这才是没有什么好写的，写一个例子结束。</p>
<pre><code>&lt;button id=&quot;myBtn&quot; onclick=&quot;console.log(&apos;click!&apos;);&quot;&gt;Click&lt;/button&gt;
</code></pre><p>这种方式问题多多：时差问题和作用域问题，还有就是HMTL代码和JS代码紧密耦合，这可是设计上的大忌。</p>
<p>第一稿写于2017.10.1</p>
<hr>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/01/JS-Event/" data-id="cj8imchlg0003e6jxj6uu3zxa" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ES6-class" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/30/ES6-class/" class="article-date">
  <time datetime="2017-09-30T14:21:11.000Z" itemprop="datePublished">2017-09-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/09/30/ES6-class/">ES6-class</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ES6带来了类"><a href="#ES6带来了类" class="headerlink" title="ES6带来了类"></a>ES6带来了类</h1><h2 id="类的使用"><a href="#类的使用" class="headerlink" title="类的使用"></a>类的使用</h2><p>JavaScript本身就是面向对象的，只是相比于传统的面向对象语言，它的面向对象总是让人感到比较困惑，最主要的原因就是虽然是面向对象，但是没有<strong>类</strong>。看下面一个例子，传统方法创建一个对象实例，需要借助构造函数和原型对象。</p>
<pre><code>function Point(x, y) {
    this.x = x;
    this.y = y;
}
Point.prototype.toString = function() {
    return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;
};
var p = new Point(1,2);
console.log(p);                // Point {x: 1, y: 2}
console.log(p.toString());     // (1,2)
</code></pre><p>再次感谢ES6为我们带来了类，让我们可以像传统面向对象语言那样定义类class。这一次我们使用类class重新改写上面的例子。</p>
<pre><code>class Point {
    // 构造方法
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
    toString() {
        return &apos;(&apos; + this.x + &apos;,&apos; + this.y + &apos;)&apos;;
    }
}
var p = new Point(1,2);
console.log(p);                // Point {x: 1, y: 2}
console.log(p.toString());     // (1,2)
</code></pre><p>比较上面两个例子，引入类之后，明显更加符合面向对象编程的语法，但实际在实现上并没有多大改变。先解释一下构造方法constructor()，和其他面向对象编程语言的功能是一样，在实例化对象时候自动执行，其中this指向实例对象。</p>
<h2 id="类是函数"><a href="#类是函数" class="headerlink" title="类是函数"></a>类是函数</h2><p>ES6的类和构造函数没有什么本质的区别，就是改写了一下，让它变得更像我们所熟悉的传统面向对象编程中的类。我们知道JavaScript的数据类型（5种基本数据类型和一种引用数据类型），那么类属于哪一种数据类型，我们使用typeof操作符来看一下：</p>
<pre><code>class Person {}
var p = new Person();
console.log(typeof Person);   // function
console.log(Person === Person.prototype.constructor);  // true
console.log(p.constructor === Person.prototype.constructor);  // true
</code></pre><p>很明显，类的数据类型是function，说明它和构造函数没有什么区别，第二行说明类本身指向了它的原型对象的constructor(构造函数)属性，这也是构造函数的性质，所以类不过就是把构造函数重新改写了一遍，让人更容易理解。使用类来创建对象实例也是使用new，和构造函数的用法完全一致。</p>
<p>现在，有一点已经明白了，类并没有带来什么新的东西，<strong>类不过是对构造函数的改写</strong>，在类里面写的方法，其实都定义在它的原型对象的属性上去了。另外对象实例的constructor方法就是类的原型对象的constructor方法，这又和构造函数创建对象实例是一致的。</p>
<blockquote>
<p>类和模块的内部，默认都是严格模式，不需要使用‘use strict’来指定。</p>
</blockquote>
<h2 id="类的constructor方法"><a href="#类的constructor方法" class="headerlink" title="类的constructor方法"></a>类的constructor方法</h2><p><strong>constructor方法</strong>是类的默认方法，通过new命令生成对象实例时，自动调用该方法。之前也说过了，该方法和传统面向对象编程语言里的用法是一样的，生成对象实例时自动调用。如果没有定义的话，会默认添加一个空的constructor方法。</p>
<p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象（谁不正常会这样做），所以在constructor方法一般就不要写return了，让它默认返回实例对象好了。比如下面这样：</p>
<pre><code>class Person {
    constructor() {}
}
var p = new Person();
console.log(p instanceof Person);     // true
</code></pre><h2 id="类的对象实例"><a href="#类的对象实例" class="headerlink" title="类的对象实例"></a>类的对象实例</h2><ol>
<li><p><strong>生成类的对象实例，必须要用new</strong>，这和构造函数生成对象实例是一样的，new绑定了this到对象实例。</p>
</li>
<li><p>实例的属性除非显式定义在其本身（this对象），否则都是定义在原型上（class上）。对象实例的属分为实例属性和原型属性。第一个例子，写在构造函数里，直接定义在this对象上的就是实例属性 <em>this.x = x;</em> ，写在原型对象上的属性 <em>Point.prototype.toString</em> 就是原型属性（所有对象实例共享）。</p>
</li>
<li><p>类的所有对象实例共享一个原型对象，不解释了。</p>
</li>
</ol>
<h2 id="类class表达式"><a href="#类class表达式" class="headerlink" title="类class表达式"></a>类class表达式</h2><p>类的数据类型是函数，函数有的类肯定也有，所以类可以用表达式来定义也没有什么奇怪的。写到这里越来越觉得，类就是把函数的function换成了class，当然还有一些小小的改动。</p>
<p>函数表达式在JavaScript是一个很重要的概念，这里不具体解释，看一个例子：</p>
<pre><code>var myFunc = function() {
    console.log(&apos;I am function.&apos;);
};
myFunc();       // I am function.
</code></pre><p>类比函数表达式，可以写类表达式：</p>
<pre><code>var myClass = class {
    sayHi() {
        console.log(&apos;I am function.&apos;);
    }
};
var ins = new myClass();
ins.sayHi();   // I am function.
</code></pre><p>同样还有立即执行函数，自然也有立即执行类，生成一个对象实例，看下面这个例子：</p>
<pre><code>var person = new class Person {
    constructor(name) {
        this.name = name;
    }
    sayHi() {
        console.log(&apos;Hi, I am &apos; + this.name);
    }
}(&apos;Tom&apos;);
person.sayHi();     // Hi, I am Tom
</code></pre><p>也没什么解释的，定义类的时候直接new生成一个对象实例。</p>
<h2 id="类不存在变量提升"><a href="#类不存在变量提升" class="headerlink" title="类不存在变量提升"></a>类不存在变量提升</h2><p>一句话<strong>先定义，后使用</strong>。</p>
<h2 id="私有属性和方法"><a href="#私有属性和方法" class="headerlink" title="私有属性和方法"></a>私有属性和方法</h2><p>ES6暂不支持，提案为属性加前缀‘#’表示为私有属性，貌似还不能使用现在，暂时pass。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/30/ES6-class/" data-id="cj8imchky0000e6jxnldi7bsx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">September 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/10/08/JSON/">JavaScript 和 JSON</a>
          </li>
        
          <li>
            <a href="/2017/10/08/js-setTimeout/">JavaScript 超时和间歇调用</a>
          </li>
        
          <li>
            <a href="/2017/10/07/http/">HTTP 概述</a>
          </li>
        
          <li>
            <a href="/2017/10/07/prototype/">继承，从原型链说起</a>
          </li>
        
          <li>
            <a href="/2017/10/05/closure/">闭包，从作用域链说起</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 Mengxin Wu<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>